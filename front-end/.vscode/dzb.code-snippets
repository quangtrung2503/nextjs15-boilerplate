{
  "genDialog": {
    "prefix": "genDialog",
    "body": [
      "import {",
      "  Dialog,",
      "  DialogPortal,",
      "  DialogOverlay,",
      "  DialogContent,",
      "  DialogTitle,",
      "  DialogDescription,",
      "} from \"@/components/ui/dialog\";",
      "import { DialogI } from \"@/interfaces/common\";",
      "import { Button } from \"../ui/button\";",
      "import { Form, Formik } from \"formik\";",
      "import { Fragment } from \"react\";",
      "import { useTranslation } from \"react-i18next\";",
      "",
      "interface DialogProps extends DialogI<any> {}",
      "",
      "const $1 = (props: DialogProps) => {",
      "  const { isOpen, toggle, onSubmit } = props;",
      "  const { t } = useTranslation(\"shared\");",
      "",
      "  return (",
      "    <Dialog open={isOpen} onOpenChange={toggle}>",
      "      <DialogPortal>",
      "        <DialogOverlay />",
      "        <DialogContent>",
      "          <Formik initialValues={{}} onSubmit={onSubmit || (() => {})}>",
      "            {({ isSubmitting }) => {",
      "              return (",
      "                <Fragment>",
      "                  <DialogTitle>Title example</DialogTitle>",
      "                  <DialogDescription>Content example</DialogDescription>",
      "",
      "                  <Form className=\"mt-[25px] flex justify-end gap-2\">",
      "                    <Button type=\"submit\" isLoading={isSubmitting}>",
      "                      {t(\"yes\")}",
      "                    </Button>",
      "                    <Button variant=\"ghost\" type=\"button\" onClick={toggle}>",
      "                      {t(\"close\")}",
      "                    </Button>",
      "                  </Form>",
      "                </Fragment>",
      "              );",
      "            }}",
      "          </Formik>",
      "        </DialogContent>",
      "      </DialogPortal>",
      "    </Dialog>",
      "  );",
      "};",
      "",
      "export default $1;",
      ""
    ],
    "description": "genDialog"
  },
  "genToggleDialog": {
    "prefix": "genToggleDialog",
    "body": ["const [open$1, toggle$1, shouldRender$1] = useToggleDialog();"],
    "description": "genToggleDialog"
  },
  "genHooks": {
    "prefix": "genHooks",
    "body": [
      "import { useEffect, useState, useCallback, useRef } from \"react\";",
      "import cloneDeep from \"lodash/cloneDeep\";",
      "import { isArray, isEmpty } from \"lodash\";",
      "import { useSave } from \"@/stores/useStores\";",
      "import { Todo } from \"../interfaces/todo\";",
      "import todoService, {",
      "  FiltersGetTodos,",
      "  RequestGetTodos,",
      "  ResponseToDoList,",
      "} from \"../todoService\";",
      "import { showError } from \"@/helpers/toast\";",
      "",
      "/********************************************************",
      " * SNIPPET GENERATED",
      " * GUIDE",
      " * Snippet for infinite scroll with page + rowsPerPage",
      " * Maybe you should check function:",
      " * - interface Request / Response",
      " * - parseRequest",
      " * - checkConditionPass",
      " * - fetch",
      " * - refetch",
      " * - requestAPI",
      " ********************************************************/",
      "",
      "//* Check parse body request",
      "const parseRequest = (filters: FiltersGetTodos): RequestGetTodos => {",
      "  return cloneDeep({",
      "    page: filters.page,",
      "    rowsPerPage: filters.rowsPerPage,",
      "  });",
      "};",
      "",
      "const requestAPI = todoService.getTodos;",
      "",
      "const $1 = (",
      "  filters: FiltersGetTodos,",
      "  options: { isTrigger?: boolean; refetchKey?: string } = {",
      "    isTrigger: true,",
      "    refetchKey: \"\",",
      "  }",
      ") => {",
      "  //! State",
      "  const { isTrigger = true, refetchKey = \"\" } = options;",
      "  const signal = useRef(new AbortController());",
      "  const save = useSave();",
      "  const [data, setData] = useState<Todo[]>([]);",
      "  const [loading, setLoading] = useState(false);",
      "  const [refetching, setRefetching] = useState(false);",
      "  const [error, setError] = useState<unknown>(null);",
      "  const [hasMore, setHasMore] = useState(false);",
      "",
      "  //! Function",
      "  const fetch: () => Promise<ResponseToDoList> | undefined = useCallback(() => {",
      "    if (!isTrigger) {",
      "      return;",
      "    }",
      "",
      "    return new Promise((resolve, reject) => {",
      "      (async () => {",
      "        try {",
      "          const nextFilters = parseRequest(filters);",
      "          const response = await requestAPI(nextFilters, {",
      "            signal: signal.current.signal,",
      "          });",
      "          resolve(response);",
      "        } catch (error) {",
      "          setError(error);",
      "          reject(error);",
      "        }",
      "      })();",
      "    });",
      "  }, [filters, isTrigger]);",
      "",
      "  const checkConditionPass = useCallback((response: ResponseToDoList) => {",
      "    //* Check condition of response here to set data",
      "    if (isArray(response?.data)) {",
      "      setData(response?.data);",
      "      setHasMore(!isEmpty(response?.data));",
      "    }",
      "  }, []);",
      "",
      "  //* Refetch implicity (without changing loading state)",
      "  const refetch = useCallback(async () => {",
      "    try {",
      "      if (signal.current) {",
      "        signal.current.abort();",
      "        signal.current = new AbortController();",
      "      }",
      "",
      "      setRefetching(true);",
      "      const response = await fetch();",
      "      if (response) {",
      "        checkConditionPass(response);",
      "      }",
      "",
      "      setRefetching(false);",
      "    } catch (error: any) {",
      "      if (!error.isCanceled) {",
      "        showError(error);",
      "      }",
      "    }",
      "  }, [fetch, checkConditionPass]);",
      "",
      "  useEffect(() => {",
      "    save(refetchKey, refetch);",
      "  }, [save, refetchKey, refetch]);",
      "",
      "  //* Refetch with changing loading state",
      "  const refetchWithLoading = useCallback(async () => {",
      "    try {",
      "      setLoading(true);",
      "      const response = await fetch();",
      "      if (response) {",
      "        checkConditionPass(response);",
      "      }",
      "      setLoading(false);",
      "    } catch (error) {",
      "      showError(error);",
      "      setLoading(false);",
      "    }",
      "  }, [fetch, checkConditionPass]);",
      "",
      "  //* Main handler",
      "  useEffect(() => {",
      "    //* Fetch initial API",
      "    const fetchAPI = async () => {",
      "      try {",
      "        signal.current = new AbortController();",
      "        setLoading(true);",
      "        const response = await fetch();",
      "        if (response) {",
      "          checkConditionPass(response);",
      "        }",
      "      } catch (error) {",
      "        showError(error);",
      "      } finally {",
      "        setLoading(false);",
      "      }",
      "    };",
      "",
      "    fetchAPI();",
      "",
      "    return () => {",
      "      if (signal.current) {",
      "        signal.current.abort();",
      "      }",
      "    };",
      "  }, [fetch, checkConditionPass]);",
      "",
      "  return {",
      "    data,",
      "    loading,",
      "    error,",
      "    refetch,",
      "    refetchWithLoading,",
      "    refetching,",
      "    hasMore,",
      "    setData,",
      "  };",
      "};",
      "",
      "export default $1;",
      ""
    ],
    "description": "genHooks"
  },
  "genHooksPagination": {
    "prefix": "genHooksPagination",
    "body": [
      "import { useEffect, useState, useCallback, useRef } from \"react\";",
      "import cloneDeep from \"lodash/cloneDeep\";",
      "import { flatten, isArray, isEmpty } from \"lodash\";",
      "import { useSave } from \"@/stores/useStores\";",
      "import { Todo } from \"../interfaces/todo\";",
      "import todoService, {",
      "  FiltersGetTodos,",
      "  RequestGetTodos,",
      "  ResponseToDoList,",
      "} from \"../todoService\";",
      "import { showError } from \"@/helpers/toast\";",
      "",
      "/********************************************************",
      " * SNIPPET GENERATED",
      " * GUIDE",
      " * Snippet for infinite scroll with page + rowsPerPage",
      " * Maybe you should check function:",
      " * - interface Request / Response",
      " * - parseRequest",
      " * - checkConditionPass",
      " * - fetch",
      " * - refetch",
      " ********************************************************/",
      "",
      "//* Check parse body request",
      "const parseRequest = (filters: FiltersGetTodos): RequestGetTodos => {",
      "  return cloneDeep({",
      "    page: filters.page,",
      "    rowsPerPage: filters.rowsPerPage,",
      "  });",
      "};",
      "",
      "const requestAPI = todoService.getTodos;",
      "",
      "const $1 = (",
      "  filters: FiltersGetTodos,",
      "  options: { isTrigger?: boolean; refetchKey?: string } = {",
      "    isTrigger: true,",
      "    refetchKey: \"\",",
      "  }",
      ") => {",
      "  //! State",
      "  const { isTrigger = true, refetchKey = \"\" } = options;",
      "  const signal = useRef(new AbortController());",
      "  const save = useSave();",
      "  const [data, setData] = useState<Todo[]>([]);",
      "  const [loading, setLoading] = useState(false);",
      "  const [refetching, setRefetching] = useState(false);",
      "  const [loadingMore, setLoadingMore] = useState(false);",
      "  const [error, setError] = useState<unknown>(null);",
      "  const [hasMore, setHasMore] = useState(false);",
      "",
      "  //! Function",
      "  const fetch: () => Promise<ResponseToDoList> | undefined = useCallback(() => {",
      "    if (!isTrigger) {",
      "      return;",
      "    }",
      "",
      "    return new Promise((resolve, reject) => {",
      "      (async () => {",
      "        try {",
      "          const nextFilters = parseRequest(filters);",
      "          const response = await requestAPI(nextFilters);",
      "",
      "          resolve(response);",
      "        } catch (error) {",
      "          setError(error);",
      "          reject(error);",
      "        }",
      "      })();",
      "    });",
      "  }, [filters, isTrigger]);",
      "",
      "  const checkConditionPass = useCallback(",
      "    (response: ResponseToDoList, options: { isLoadmore?: boolean } = {}) => {",
      "      const { isLoadmore } = options;",
      "",
      "      //* Check condition of response here to set data",
      "      if (isArray(response?.data)) {",
      "        if (isLoadmore) {",
      "          setData((prev) => {",
      "            let nextPages = cloneDeep(prev);",
      "            nextPages = [...(nextPages || []), ...(response?.data || [])];",
      "            return nextPages;",
      "          });",
      "        } else {",
      "          setData(response?.data);",
      "        }",
      "",
      "        setHasMore(!isEmpty(response?.data));",
      "      }",
      "    },",
      "    []",
      "  );",
      "",
      "  //* Refetch implicity (without changing loading state)",
      "  const refetch = useCallback(async () => {",
      "    try {",
      "      if (signal.current) {",
      "        signal.current.abort();",
      "        signal.current = new AbortController();",
      "      }",
      "",
      "      setRefetching(true);",
      "      const page = filters?.page || 1;",
      "",
      "      let listRequest: Promise<ResponseToDoList>[] = [];",
      "      for (let eachPage = 0; eachPage < page; eachPage++) {",
      "        const nextFilters = parseRequest(filters);",
      "        nextFilters.page = eachPage;",
      "",
      "        const request = requestAPI(nextFilters);",
      "",
      "        listRequest = [...listRequest, request];",
      "      }",
      "",
      "      const responses = await Promise.allSettled(listRequest);",
      "      const allData = responses.map((el) => {",
      "        if (el.status === \"fulfilled\") {",
      "          return isArray(el?.value?.data) ? el?.value?.data : [];",
      "        }",
      "",
      "        return [];",
      "      });",
      "      setData(flatten(allData));",
      "      setRefetching(false);",
      "    } catch (error: any) {",
      "      if (!error.isCanceled) {",
      "        showError(error);",
      "      }",
      "    }",
      "  }, [filters]);",
      "",
      "  useEffect(() => {",
      "    save(refetchKey, refetch);",
      "  }, [save, refetchKey, refetch]);",
      "",
      "  useEffect(() => {",
      "    signal.current = new AbortController();",
      "",
      "    //* Fetch initial API",
      "    const fetchAPI = async () => {",
      "      try {",
      "        setLoading(true);",
      "        const response = await fetch();",
      "        if (response) {",
      "          checkConditionPass(response);",
      "          setLoading(false);",
      "        }",
      "      } catch (error) {",
      "        showError(error);",
      "      } finally {",
      "        setLoading(false);",
      "      }",
      "    };",
      "",
      "    //* Fetch more API",
      "    const fetchMore = async () => {",
      "      try {",
      "        setLoadingMore(true);",
      "        const response = await fetch();",
      "        if (response) {",
      "          checkConditionPass(response, { isLoadmore: true });",
      "        }",
      "      } catch (error) {",
      "        showError(error);",
      "      } finally {",
      "        setLoadingMore(false);",
      "      }",
      "    };",
      "",
      "    if (filters.page !== undefined && filters.page <= 0) {",
      "      fetchAPI();",
      "    } else {",
      "      //* If page / offset > 0 -> fetch more",
      "      fetchMore();",
      "    }",
      "",
      "    return () => {",
      "      if (signal.current) {",
      "        signal.current.abort();",
      "      }",
      "    };",
      "  }, [filters.page, fetch, checkConditionPass]);",
      "",
      "  return {",
      "    data,",
      "    loading,",
      "    error,",
      "    refetch,",
      "    refetching,",
      "    loadingMore,",
      "    hasMore,",
      "    setData,",
      "  };",
      "};",
      "",
      "export default $1;",
      ""
    ],
    "description": "genHooksPagination"
  },
  "genComponentTable": {
    "prefix": "genComponentTable",
    "body": [
      "import React from 'react';",
      "import CommonIcons from 'components/CommonIcons';",
      "import CommonStyles from 'components/CommonStyles';",
      "import SearchAndFilters from 'components/SearchAndFilters';",
      "import { FastField } from 'formik';",
      "import TextField from 'components/CustomFields/TextField';",
      "import useFiltersHandler from 'hooks/useFiltersHandler';",
      "import { Order } from 'interfaces/common';",
      "",
      "interface $1Props {}",
      "",
      "const initialValues = {",
      "  username: '',",
      "  email: '',",
      "  page: 0,",
      "  rowsPerPage: 5,",
      "  order: Order.desc,",
      "  orderBy: '',",
      "};",
      "",
      "const $1 = (props: $1Props) => {",
      "  //! State",
      "  const {",
      "    filters,",
      "    setFilters,",
      "    selected,",
      "    handleChangePage,",
      "    handleChangeRowsPerPage,",
      "    handleRequestSort,",
      "    handleSelectAllClick,",
      "    handleResetToInitial,",
      "    handleCheckBox,",
      "  } = useFiltersHandler(initialValues);",
      "",
      "  //! Function",
      "  const totalCount = 2;",
      "",
      "  const data = [",
      "    {",
      "      id: '1',",
      "      name: 'Pham Quy Don',",
      "      email: 'donezombie@gmail.com',",
      "    },",
      "    {",
      "      id: '2',",
      "      name: 'Pham Quy Don 2',",
      "      email: 'donezombie2@gmail.com',",
      "    },",
      "  ];",
      "",
      "  //! Render",
      "  return (",
      "    <CommonStyles.Box>",
      "      <CommonStyles.Typography variant='h4' sx={{ mb: 3 }}>",
      "        $1 management",
      "      </CommonStyles.Typography>",
      "",
      "      <CommonStyles.Typography sx={{ mb: 2 }}>",
      "        <code style={{ backgroundColor: 'rgba(0, 0, 0, 0.1)', padding: 12 }}>",
      "          {JSON.stringify({ filters: { ...filters, selected } })}",
      "        </code>",
      "      </CommonStyles.Typography>",
      "",
      "      <SearchAndFilters",
      "        initialValues={initialValues}",
      "        onSubmit={(values) => {",
      "          setFilters(values);",
      "        }}",
      "        onReset={() => {",
      "          handleResetToInitial();",
      "        }}",
      "        renderFilterFields={() => {",
      "          return (",
      "            <CommonStyles.Box sx={{ gap: 2, display: 'flex' }}>",
      "              <FastField",
      "                component={TextField}",
      "                name='username'",
      "                placeholder='Username'",
      "                label='Username'",
      "              />",
      "              <FastField component={TextField} name='email' placeholder='Email' label='Email' />",
      "            </CommonStyles.Box>",
      "          );",
      "        }}",
      "      />",
      "",
      "      <CommonStyles.Box sx={{ mt: 3 }}>",
      "        <CommonStyles.Typography variant='h6' sx={{ mb: 1 }}>",
      "          Total record(s): {totalCount}",
      "        </CommonStyles.Typography>",
      "        <CommonStyles.Table",
      "          order={filters?.order || Order.desc}",
      "          orderBy={filters?.orderBy}",
      "          selected={selected}",
      "          page={filters?.page || 0}",
      "          rowsPerPage={filters?.rowsPerPage || 5}",
      "          headCells={[",
      "            {",
      "              label: 'Name',",
      "              id: 'name',",
      "            },",
      "            {",
      "              label: 'Email',",
      "              id: 'email',",
      "            },",
      "          ]}",
      "          totalCount={totalCount}",
      "          rows={data}",
      "          handleChangePage={handleChangePage}",
      "          handleChangeRowsPerPage={handleChangeRowsPerPage}",
      "          handleRequestSort={handleRequestSort}",
      "          handleSelectAllClick={handleSelectAllClick}",
      "          handleCheckBox={handleCheckBox}",
      "          showCheckBox",
      "        />",
      "      </CommonStyles.Box>",
      "    </CommonStyles.Box>",
      "  );",
      "};",
      "",
      "export default React.memo($1);",
      ""
    ],
    "description": "genComponentTable"
  },
  "genComponent": {
    "prefix": "genComponent",
    "body": [
      "import React from \"react\";",
      "import { cn } from \"@/lib/utils\";",
      "",
      "interface $1Props {}",
      "",
      "const $1 = (props: React.PropsWithChildren<$1Props>) => {",
      "  //! State",
      "",
      "  //! Function",
      "",
      "  //! Render",
      "  return <div className={cn(\"component:$1\")}>{props.children}</div>;",
      "};",
      "",
      "export default $1;",
      ""
    ],
    "description": "genComponent"
  }
}
